package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.79

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"strconv"

	"github.com/ShopOnGO/search-service/internal/elastic"
	"github.com/ShopOnGO/search-service/internal/graph/model"
	"github.com/ShopOnGO/search-service/internal/product"
)

// SearchProducts выполняет поиск в Elasticsearch и возвращает model.SearchResponse
func (r *queryResolver) SearchProducts(ctx context.Context, input model.SearchInput) (*model.SearchResponse, error) {
	// default values
	page := 1
	limit := 20

	if input.Page != nil && *input.Page > 0 {
		page = int(*input.Page)
	}
	if input.Limit != nil && *input.Limit > 0 {
		limit = int(*input.Limit)
	}
	if limit > 100 {
		limit = 100
	}

	var mustClauses []map[string]interface{}

	// Поиск по имени
	if input.Name != nil && *input.Name != "" {
		mustClauses = append(mustClauses, map[string]interface{}{
			"multi_match": map[string]interface{}{
				"query":     *input.Name,
				"fields":    []string{"name^2", "description"},
				"type":      "best_fields",
				"fuzziness": "AUTO",
			},
		})
	}

	// Фильтр по цене
	if input.MinPrice != nil || input.MaxPrice != nil {
		priceRange := make(map[string]interface{})
		if input.MinPrice != nil {
			priceRange["gte"] = *input.MinPrice
		}
		if input.MaxPrice != nil {
			priceRange["lte"] = *input.MaxPrice
		}

		// В nested query путь — "variants", а поле внутри nested — "price"
		rangeQuery := map[string]interface{}{
			"nested": map[string]interface{}{
				"path": "variants",
				"query": map[string]interface{}{
					"range": map[string]interface{}{
						"variants.price": priceRange,
					},
				},
			},
		}

		mustClauses = append(mustClauses, rangeQuery)
	}


	var query map[string]interface{}
	if len(mustClauses) == 0 {
		query = map[string]interface{}{
			"query": map[string]interface{}{
				"match_all": map[string]interface{}{},
			},
		}
	} else {
		query = map[string]interface{}{
			"query": map[string]interface{}{
				"bool": map[string]interface{}{
					"must": mustClauses,
				},
			},
		}
	}

	// pagination + sort
	query["from"] = (page - 1) * limit
	query["size"] = limit
	query["sort"] = []map[string]interface{}{
		{"_score": map[string]interface{}{"order": "desc"}},
	}

	var buf bytes.Buffer
	if err := json.NewEncoder(&buf).Encode(query); err != nil {
		log.Printf("Query serialization error: %v", err)
		return nil, fmt.Errorf("query serialization: %w", err)
	}

	res, err := elastic.ESClient.Search(
		elastic.ESClient.Search.WithIndex(elastic.Index),
		elastic.ESClient.Search.WithBody(&buf),
		elastic.ESClient.Search.WithTrackTotalHits(true),
	)
	if err != nil {
		log.Printf("Elasticsearch search error: %v", err)
		return nil, fmt.Errorf("elasticsearch search: %w", err)
	}
	defer res.Body.Close()

	if res.StatusCode != http.StatusOK {
		bodyBytes, _ := io.ReadAll(res.Body)
		log.Printf("Elasticsearch returned status %d: %s", res.StatusCode, string(bodyBytes))
		return nil, fmt.Errorf("elasticsearch returned status %d", res.StatusCode)
	}

	var esResp struct {
		Hits struct {
			Total struct {
				Value int `json:"value"`
			} `json:"total"`
			Hits []struct {
				Source product.ESProduct `json:"_source"`
			} `json:"hits"`
		} `json:"hits"`
	}

	bodyBytes, err := io.ReadAll(res.Body)
	if err != nil {
		log.Printf("Error reading response body: %v", err)
		return nil, fmt.Errorf("read response body: %w", err)
	}

	if err := json.Unmarshal(bodyBytes, &esResp); err != nil {
		log.Printf("Unmarshal error: %v\nRaw: %s", err, string(bodyBytes))
		return nil, fmt.Errorf("unmarshal es response: %w", err)
	}

	// Конвертируем в model.Product
	products := make([]*model.Product, 0, len(esResp.Hits.Hits))
	for _, hit := range esResp.Hits.Hits {
		products = append(products, convertESProductToModel(&hit.Source))
	}

	total := esResp.Hits.Total.Value
	pages := 0
	if total > 0 {
		pages = (total + limit - 1) / limit
	}

	resp := &model.SearchResponse{
		Products: products,
		Total:    int32(total),
		Page:     int32(page),
		Limit:    int32(limit),
		Pages:    int32(pages),
	}

	return resp, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }


func convertESProductToModel(p *product.ESProduct) *model.Product {
	// Description pointer
	var descPtr *string
	if p.Description != "" {
		descPtr = &p.Description
	}

	// Category/Brand cast
	cat := int32(p.CategoryID)
	brand := int32(p.BrandID)

	// Variants
	var variants []*model.Variant
	for _, v := range p.Variants {
		// sizes convert []int -> []int32
		sizes32 := make([]int32, 0, len(v.Sizes))
		for _, s := range v.Sizes {
			sizes32 = append(sizes32, int32(s))
		}

		var matPtr *string
		if v.Material != "" {
			matPtr = &v.Material
		}

		variants = append(variants, &model.Variant{
			VariantID: v.VariantID,
			Sku:       v.SKU,
			Price:     v.Price,
			Sizes:     sizes32,
			Colors:    v.Colors,
			Material:  matPtr,
			Stock:     int32(v.Stock),
			Rating:    v.Rating,
		})
	}

	// ID в model.Product — string
	idStr := strconv.FormatUint(uint64(p.ID), 10)

	return &model.Product{
		ID:          idStr,
		Name:        p.Name,
		Description: descPtr,
		CategoryID:  cat,
		BrandID:     brand,
		Variants:    variants,
	}
}
