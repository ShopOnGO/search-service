package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.79

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"

	"github.com/ShopOnGO/search-service/internal/elastic"
	"github.com/ShopOnGO/search-service/internal/graph/model"
	"github.com/ShopOnGO/search-service/internal/product"
)

// SearchProducts выполняет поиск в Elasticsearch и возвращает model.SearchResponse
func (r *queryResolver) SearchProducts(ctx context.Context, input model.SearchInput) (*model.SearchResponse, error) {
	// default values
	page := 1
	limit := 20

	if input.Page != nil && *input.Page > 0 {
		page = int(*input.Page)
	}
	if input.Limit != nil && *input.Limit > 0 {
		limit = int(*input.Limit)
	}
	if limit > 100 {
		limit = 100
	}

	var mustClauses []map[string]interface{}

	// Поиск по имени и описанию
	if input.Name != nil && *input.Name != "" {
		mustClauses = append(mustClauses, map[string]interface{}{
			"multi_match": map[string]interface{}{
				"query":     *input.Name,
				"fields":    []string{"name^2", "description"},
				"type":      "best_fields",
				"fuzziness": "AUTO",
			},
		})
	}

	// // Фильтр по конкретному id продукта
	// if input.ProductID != nil && *input.ProductID != "" {
	// 	mustClauses = append(mustClauses, map[string]interface{}{
	// 		"term": map[string]interface{}{
	// 			"id": *input.ProductID,
	// 		},
	// 	})
	// }

	// // Фильтр по конкретному id варианта продукта
	// if input.VariantID != nil && *input.VariantID != "" {
	// 	mustClauses = append(mustClauses, map[string]interface{}{
	// 		"term": map[string]interface{}{
	// 			"variants.variant_id": *input.VariantID,
	// 		},
	// 	})
	// }

	// // Фильтр по конкретному sku варианта продукта
	// if input.SKU != nil && *input.SKU != "" {
	// 	mustClauses = append(mustClauses, map[string]interface{}{
	// 		"term": map[string]interface{}{
	// 			"variants.sku": *input.SKU,
	// 		},
	// 	})
	// }

	// // Фильтр по конкретному material варианта продукта
	// if input.Material != nil && *input.Material != "" {
	// 	mustClauses = append(mustClauses, map[string]interface{}{
	// 		"term": map[string]interface{}{
	// 			"variants.material": *input.Material,
	// 		},
	// 	})
	// }

	// // Фильтр по конкретному color варианта продукта
	// if input.Color != nil && *input.Color != "" {
	// 	mustClauses = append(mustClauses, map[string]interface{}{
	// 		"term": map[string]interface{}{
	// 			"variants.colors": *input.Color,
	// 		},
	// 	})
	// }

	// // Фильтр по конкретному size варианта продукта
	// if input.Size != nil && *input.Size != 0 {
	// 	mustClauses = append(mustClauses, map[string]interface{}{
	// 		"term": map[string]interface{}{
	// 			"variants.sizes": *input.Size,
	// 		},
	// 	})
	// }

	// // Фильтр по конкретному rating варианта продукта
	// if input.Rating != nil && *input.Rating != 0 {
	// 	mustClauses = append(mustClauses, map[string]interface{}{
	// 		"term": map[string]interface{}{
	// 			"variants.rating": *input.Rating,
	// 		},
	// 	})
	// }

	// // Фильтр по конкретному stock варианта продукта
	// if input.Stock != nil && *input.Stock != 0 {
	// 	mustClauses = append(mustClauses, map[string]interface{}{
	// 		"term": map[string]interface{}{
	// 			"variants.stock": *input.Stock,
	// 		},
	// 	})
	// }

	// Фильтр по category_id
	if input.CategoryID != nil {
		mustClauses = append(mustClauses, map[string]interface{}{
			"term": map[string]interface{}{
				"category_id": *input.CategoryID,
			},
		})
	}

	// Фильтр по brand_id
	if input.BrandID != nil {
		mustClauses = append(mustClauses, map[string]interface{}{
			"term": map[string]interface{}{
				"brand_id": *input.BrandID,
			},
		})
	}

	// Фильтр по цене
	if input.MinPrice != nil || input.MaxPrice != nil {
		priceRange := make(map[string]interface{})
		if input.MinPrice != nil {
			priceRange["gte"] = *input.MinPrice
		}
		if input.MaxPrice != nil {
			priceRange["lte"] = *input.MaxPrice
		}

		rangeQuery := map[string]interface{}{
			"nested": map[string]interface{}{
				"path": "variants",
				"query": map[string]interface{}{
					"range": map[string]interface{}{
						"variants.price": priceRange,
					},
				},
			},
		}

		mustClauses = append(mustClauses, rangeQuery)
	}

	var query map[string]interface{}
	if len(mustClauses) == 0 {
		query = map[string]interface{}{
			"query": map[string]interface{}{
				"match_all": map[string]interface{}{},
			},
		}
	} else {
		query = map[string]interface{}{
			"query": map[string]interface{}{
				"bool": map[string]interface{}{
					"must": mustClauses,
				},
			},
		}
	}

	// pagination + sort
	query["from"] = (page - 1) * limit
	query["size"] = limit
	query["sort"] = []map[string]interface{}{
		{"_score": map[string]interface{}{"order": "desc"}},
	}

	var buf bytes.Buffer
	if err := json.NewEncoder(&buf).Encode(query); err != nil {
		log.Printf("Query serialization error: %v", err)
		return nil, fmt.Errorf("query serialization: %w", err)
	}

	res, err := elastic.ESClient.Search(
		elastic.ESClient.Search.WithIndex(elastic.Index),
		elastic.ESClient.Search.WithBody(&buf),
		elastic.ESClient.Search.WithTrackTotalHits(true),
	)
	if err != nil {
		log.Printf("Elasticsearch search error: %v", err)
		return nil, fmt.Errorf("elasticsearch search: %w", err)
	}
	defer res.Body.Close()

	if res.StatusCode != http.StatusOK {
		bodyBytes, _ := io.ReadAll(res.Body)
		log.Printf("Elasticsearch returned status %d: %s", res.StatusCode, string(bodyBytes))
		return nil, fmt.Errorf("elasticsearch returned status %d", res.StatusCode)
	}

	var esResp struct {
		Hits struct {
			Total struct {
				Value int `json:"value"`
			} `json:"total"`
			Hits []struct {
				Source product.ESProduct `json:"_source"`
			} `json:"hits"`
		} `json:"hits"`
	}

	bodyBytes, err := io.ReadAll(res.Body)
	if err != nil {
		log.Printf("Error reading response body: %v", err)
		return nil, fmt.Errorf("read response body: %w", err)
	}

	if err := json.Unmarshal(bodyBytes, &esResp); err != nil {
		log.Printf("Unmarshal error: %v\nRaw: %s", err, string(bodyBytes))
		return nil, fmt.Errorf("unmarshal es response: %w", err)
	}

	// Конвертируем в model.Product
	products := make([]*model.Product, 0, len(esResp.Hits.Hits))
	for _, hit := range esResp.Hits.Hits {
		products = append(products, ConvertESProductToModel(&hit.Source))
	}

	total := esResp.Hits.Total.Value
	pages := 0
	if total > 0 {
		pages = (total + limit - 1) / limit
	}

	resp := &model.SearchResponse{
		Products: products,
		Total:    int32(total),
		Page:     int32(page),
		Limit:    int32(limit),
		Pages:    int32(pages),
	}

	return resp, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }